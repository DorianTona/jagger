// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Jagger
{
    public static void main(String args[]) throws ParseException,FileNotFoundException
    {
        Jagger parser;
        if(args.length != 0) {
            parser = new Jagger(new FileInputStream(args[0]));
        } else {
            parser = new Jagger(System.in);
        }
        
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < EOL: "\n" >                             // End of line.
|   < STRING: "\"" ((~["\n", "\r", "\""])*)? "\"" >     // string
//|   < VARIABLE: "var "((["a"-"z","A"-"Z", "0"-"9"])*)?  >
}

// Main loop: read expressions on a line until end of file.
//     mainloop â†’ (expression <EOL>)* <EOF>

void mainloop():
{ Exp a; }
{
    (
        "print("a=expression()")" <EOL> {
        Eval ev = new Eval();
        ev.print(a);
    } |
        a=expression() <EOL> {
        PrettyPrinter pp = new PrettyPrinter();
        pp.print(a);
        System.out.println();
    }
    )*
    <EOF>
}
// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Exp expression():
{ Exp a,b,c; }
{
    "if" a=expression() "then" b=expression() "else" c=expression()
    { return new Ins(a,b,c); }
    |
    "let" a=expression() "in" b=expression() "end"
    { return new Scope(new Exp[]{a},new Exp[]{b});}
    |
    a=term()
    (
      "+"   b=expression()  { return a = new Add(a,b); }
    | "-"   b=expression()  { return a = new Sub(a,b); }
    | "=="  b=expression()  { return a = new Equal(a,b); }
    | "<>"  b=expression()  { return a = new NonEqual(a,b); }
    | ">"   b=expression()  { return a = new Sup(a,b); }
    | "<"   b=expression()  { return a = new Inf(a,b); }
    | ">="  b=expression()  { return a = new SupEqual(a,b); }
    | "<="  b=expression()  { return a = new InfEqual(a,b); }
    | ":="  b=expression()  { return a = new Affect(a,b); }
    )? { return a; }
}


// Term.
// T -> F ('*'F | '/'F)*
Exp term():
{ Exp a,b; }
{
    a=unary()
    (
      "*" b=term() { a = new Mul(a,b); }
    | "/" b=term() { a = new Div(a,b); }
    )* { return a; }
}

Exp unary():
{Exp a;}
{
      "+" a=factor() { return a; }
    | "-" a=factor() { return new UnNeg(a); }
    | a=factor() { return a; }
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Exp factor():
{ Token t; Exp e;}
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
    | t=<STRING> { return new Chaine(t.toString()); }
    //| t=<VARIABLE> { return new Variable(t.toString()); }
    | "(" e=expression() ")" { return e; }
}
