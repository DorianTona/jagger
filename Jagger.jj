// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)

import java.util.ArrayList;
import java.util.HashMap;

public class Jagger
{
    static PrettyPrinter pp = new PrettyPrinter();
    static Eval ev = new Eval();
}


PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" | "\n" }

// Token specifications.
TOKEN:
{
    //Keywords
    < PRINT: "print" >

|   < IF: "if" >
|   < THEN: "then" >
|   < ELSE: "else" >

|   < LET: "let" >
|   < VAR: "var" >
|   < IN: "in" >
|   < END: "end" >

    //Other tokens
|   < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >                        // A decimal number.
|   < DIGIT: ["0"-"9"] >                                            // A decimal digit.
|   < STRING: "\"" ((~["\n", "\r", "\""])*)? "\"" >                 // string
|   < LRB: "(" >                                                    // Left Round Bracket
|   < RRB: ")" >                                                    // Right Round BRacket
|   < VARIABLE: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z","0"-"9"])* >   // variable
|   < ASSIGNMENT: ":=" >
|   < COMMA: "," >
}

//let var i := 10 in print(i), let var i := i * i in print(i) end, print(i) end

// Main loop: read expressions on a line until end of file.
//  mainloop → (statement)* <EOF>
void mainloop():
{ Exp a; }
{
    ( a=statement() )* <EOF>
}

//  statement → scope | print(comparison())
Exp statement():
{ Exp e; }
{
    (   
      e=scope()
    | <PRINT> <LRB> e=comparison() <RRB> { e = new Print(e); ev.print(e); }
    )
    { return e; }
}

//  scope → let (declaration)* in instruction (, instruction)* end
Exp scope():
{
    Exp a, e;
    Scope s = new Scope();
}
{
    <LET>
        (e = declaration(s))*
    <IN>
        e = instruction(s) (<COMMA> e = instruction(s))*
    <END>
    { 
        pp.print(s);
        System.out.println("\nResult :");
        ev.print(s);
        s.exit();
        return s;
    }
}

//  declaration → (var <VARIABLE> := comparison)*
Scope declaration(Scope s):
{
    Token t;
    Exp e;
}
{
    (
      <VAR> t=<VARIABLE> <ASSIGNMENT> e=comparison() { s.addDeclaration(t.toString(), e); } 
    ) { return s; }
}

Exp instruction(Scope s):
{
    Exp a; 
    Token t;
}
{
    (
      a = scope() { s.addInstruction(a); }
    | <PRINT> <LRB> a=comparison() <RRB> { s.addInstruction( new Print(a)); }
    | a=comparison() (<COMMA> a=comparison())*
    ) { return s; }
}

// Comparison operators
// C -> E ('=='E | '<>'E | '>'E | '<'E | '>='E | '<='E)*
Exp comparison():
{ Exp a,b; }
{
    a=expression()
    (
      "=="  b=expression()  { a = new Equal(a,b); }
    | "<>"  b=expression()  { a = new NonEqual(a,b); }
    | ">"   b=expression()  { a = new Sup(a,b); }
    | "<"   b=expression()  { a = new Inf(a,b); }
    | ">="  b=expression()  { a = new SupEqual(a,b); }
    | "<="  b=expression()  { a = new InfEqual(a,b); }
    )? { return a; }
}

// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Exp expression():
{ Exp a,b; }
{
    a=term()
    (
      "+" b=term()  { a = new Add(a,b); }
    | "-" b=term()  { a = new Sub(a,b); }
    )* { return a; }
}


// Term.
// T -> U ('*'T | '/'T)*
Exp term():
{ Exp a,b; }
{
    a=unary()
    (
      "*" b=term() { a = new Mul(a,b); }
    | "/" b=term() { a = new Div(a,b); }
    )* { return a; }
}

// Unary operator.
// U -> ('*'T | '/'T | T)*
Exp unary():
{ Exp a; }
{
      "-" a=ternary() { return a = new UnNeg(a); }
    | ("+" a=ternary() | a=ternary()) { return a; }
}

//ternary operators
// T -> ('if' C 'then' C 'else' C | F)
Exp ternary():
{ Exp a,b,c; }
{   
    (
      <IF> a=comparison() <THEN> b=comparison() <ELSE> c=comparison() {  a = new Ins(a,b,c); }
    | a=factor()
    )+ { return a; }
}

// Factor of an expression.
// F -> <NUMBER> | <STRING> | <VARIABLE> | "(" E ")"
Exp factor():
{ Token t; Exp e;}
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
    | t=<STRING> { return new Chaine(t.toString()); }
    | t=<VARIABLE> { return new Variable(t.toString()); }
    | <LRB> e=comparison() <RRB> { return e; }
}
